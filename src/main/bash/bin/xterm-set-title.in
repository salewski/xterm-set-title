#!@BASH_SH@ -
# SPDX-License-Identifier: GPL-2.0-or-later

# @configure_input@
#
# Copyright (c) 2018, 2020 Alan D. Salewski <salewski@att.net>
#
#     This program is free software; you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation; either version 2 of the License, or
#     (at your option) any later version.
#
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with this program; if not, write to the Free Software Foundation,
#     Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301,, USA.

#
# xterm-set-title: Allows easy setting of the xterm(1) window title from the
# command line (or from other programs).
#

declare -r PROG='xterm-set-title'

# Comma-space-separated list
declare -r COPYRIGHT_DATES='2018, 2020'

# Filtered-in at build time; has the form (without the quotes):
#     "Person Name <email@example.com"
declare -r MAINTAINER='@DFLT_MAINTAINER_FULL@'

# This variable is replaced by the current xterm-set-title project version
# number at build time.
declare -r VERSION='@VERSION@'

# This variable is replaced at build time
declare -r gl_const_build_date='@BUILD_DATE@'
declare -r gl_const_release="${VERSION}  (built: ${gl_const_build_date})"


# By default we'll use the external programs found at configure-time (values
# are filtered-in here at build time). But we allow the user to override any
# particular tool by setting an environment variable named after the tool
# (with hyphen chars changed to underscores).

CAT_PROG="${CAT:-@CAT@}"


# Note that we use an "application" $TRACING flag separate from bash's
# built-in 'xtrace' (set -x) shell option. This allows us to have a general
# notion of user-requested verbosity separate from any selectively placed
# 'set -x/set +x' sections we may plug into the code while working on the
# program itself; similarly for places where we might want to avoid trace
# output while debugging by selectively placing 'set +x/set -x' sections; both
# of those behaviors would be much more cumbersome to achieve if we just
# checked for 'x' in $- at runtime.
#
BE_VERBOSE=false   # enable with one '-v' (--verbose) opt
DEBUGGING=false    # enable with two '-v' (--verbose) opts
TRACING=false      # enable with three or more '-v' (--verbose) opts


# Note that we export the cleanup hook function definitions, but not the
# ${F_CLEANUP_HOOK_NAMES} array. We'll create a separate copy of that in any
# subshell that needs to register its own cleanup hooks.
#
declare -a F_CLEANUP_HOOK_NAMES=()

function f_add_cleanup_hook_name () {

    : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): entered

    F_CLEANUP_HOOK_NAMES+=( $1 );
}
export -f f_add_cleanup_hook_name


function f_cleanup () {

    : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): entered

    if test ${#F_CLEANUP_HOOK_NAMES[@]} -eq 0; then
        : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): No cleanup hooks, so nothing to do
        return
    fi

    local __t_cleanup_hook
    local __t_idx

    let __t_idx=${#F_CLEANUP_HOOK_NAMES[@]}-1

    # Note that we're running the cleanup hooks in opposite order from which
    # they were installed.
    #
    while test ${__t_idx} -ge 0; do

        __t_cleanup_hook=${F_CLEANUP_HOOK_NAMES[${__t_idx}]}

        if $DEBUGGING; then
            printf "${PROG} (info): running cleanup hook: [%s]\n" "${__t_cleanup_hook}" 1>&2
        fi

        test -n "${__t_cleanup_hook}" && eval "${__t_cleanup_hook}"

        let __t_idx=${__t_idx}-1
    done
}
export -f f_cleanup

function f_cleanup_and_die () {
    : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): entered
    f_cleanup
    exit 1
}
export -f f_cleanup_and_die

trap 'printf "$PROG (warn): HUP signal caught; bailing out\n"  1>&2; f_cleanup_and_die' HUP
trap 'printf "$PROG (warn): INT signal caught; bailing out\n"  1>&2; f_cleanup_and_die' INT
trap 'printf "$PROG (warn): QUIT signal caught; bailing out\n" 1>&2; f_cleanup_and_die' QUIT
trap 'printf "$PROG (warn): TERM signal caught; bailing out\n" 1>&2; f_cleanup_and_die' TERM

trap 'f_cleanup' EXIT


f_print_help () {

    "${CAT_PROG}" <<EOF
usage: $PROG [OPTION...] <NEW_TITLE>
       $PROG [-h|--help]
       $PROG [-v|--version]
Emits NEW_TITLE surrounded by escape characters to set the xterm(1) window title.

  -h, --help      Print this help message on stdout
  -V, --version   Print the version of the program on stdout
  -v, --verbose   Tell what is being done. Two or more -v options turns on tracing (set -x)

      --          Signals the end of options and disables further options processing. All
                    remaining arguments will be ignored

Report bugs to ${MAINTAINER}
EOF
}

f_print_version () {
    "${CAT_PROG}" <<EOF
${PROG} ${gl_const_release}
Copyright (C) ${COPYRIGHT_DATES} Alan D. Salewski
License GPLv2+: GNU GPL version 2 or later <https://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Written by Alan D. Salewski.
EOF
}


# main of program starts here

pos_last_plus_one=$(( $# + 1 ))

# Each value is one or zero, which indicates whether or not the option is
# expected to have an argument.
#
declare -A longopt_spec=(
    ['help']=0      # -h, --help
    ['version']=0   # -V, --version

    ['verbose']=0   # -v, --verbose
)

# internal sanity check
for one_key in "${!longopt_spec[@]}"; do
    one_val=${longopt_spec[${one_key}]}
    if [[ $one_val =~ ^[01]$ ]]; then :; else
        printf "${PROG} (BUG) [line $LINENO]: value (%s) for longopt key '%s' must be either 0 or 1; bailing out\n" \
               "${one_val}" "${one_key}" 1>&2
        exit 1
    fi
done

if test $# -gt 0; then

    # Using getopts in "silent mode". Note that adding '-' to the optstring
    # allows us to process GNU-style long-form options; that option is
    # specified to take an argument to cause getopts to place whatever follows
    # the second '-' character into OPTARG.
    #
    # Note that getopts will automatically stop processsing options upon
    # encountering '--', but we still need to deal with the pathological form
    # --=BLAH (no option name, just a value using the equals-sign syntax).
    #
    while builtin getopts ':-:hVv' opt
    do
        : $PROG \(trace: $LINENO\):    opt is: $opt
        : $PROG \(trace: $LINENO\): OPTARG is: $OPTARG

        # cosmetic: for log/error messages
        t_pfx='-'  # assume short-form option

        if test "${opt}" = '-'; then

            # Intercepting processing of long-form option. This conditional
            # block will set up the 'opt', 'OPTARG', and 'OPTIND' variables
            # for the code that follows, just as if getopts had the capability
            # to process long-form options.

            t_pfx='--'

            # OPTARG here is one of:
            #
            #     =BLAH    (which means user specified '--=BLAH')
            # or:
            #     foo
            # or:
            #     foo=FOOVAL

            if [[ ${OPTARG} =~ .*=.* ]]; then

                : $PROG \(trace: $LINENO\): OPTARG is name=value style

                # Keep everything up to the first '=' sign. Note that if the
                # option was specified as: --foo=FOOVAL, then $opt here will
                # be 'foo' (no hyphen chars).
                opt=${OPTARG/=*/}
                : $PROG \(trace: $LINENO\): opt is: $opt

                : $PROG \(trace: $LINENO\): a long option name must be at least two characters in length
                if test ${#opt} -le 1; then
                    printf "${PROG} (error): invalid long option '%s%s'; bailing out\n" "${t_pfx}" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                t_exists=false
                for one_key in "${!longopt_spec[@]}"; do
                    if test "${opt}" = "${one_key}"; then
                        t_exists=true
                        break
                    fi
                done

                if $t_exists; then :; else
                    # Unrecognized option; note that we need to restore the
                    # leading '-' chars that getopts has sliced off.
                    #
                    printf "${PROG} (error): unrecognized long option '%s%s'; bailing out\n" "${t_pfx}" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                # Since we know the option was specified in --foo=BAR form,
                # the option was specified erroneously unless the option's
                # long-form spec indicates that it can accept an argument.
                #
                if test ${longopt_spec[${opt}]} -ne 1; then
                    printf "${PROG} (error): option '%s%s' does not take an argument; bailing out\n" "${t_pfx}" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                OPTARG=${OPTARG#*=}  # keep everything after the first '=' sign
                : $PROG \(trace: $LINENO\): OPTARG is: $OPTARG

            else
                : $PROG \(trace: $LINENO\): OPTARG is name-only style

                opt="$OPTARG"
                : $PROG \(trace: $LINENO\): opt is: $opt

                if test -z "${opt}"; then

                    # This should be a "can't happen" scenario; since bash's
                    # 'getopts' implementation should directly handle the
                    # magic '--' token, we should never fall through here.

                    printf "${PROG} (BUG) [line $LINENO]: received empty OPTARG, which means getopts did not handle the stand-alone '--' token; bailing out\n" 1>&2
                    exit 1
                fi

                : $PROG \(trace: $LINENO\): a non-empty long option name must be at least two characters in length
                if test ${#opt} -lt 2; then
                    printf "${PROG} (error): invalid long option '%s%s'; bailing out\n" "${t_pfx}" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                t_exists=false
                for one_key in "${!longopt_spec[@]}"; do
                    if test "${opt}" = "${one_key}"; then
                        t_exists=true
                        break
                    fi
                done

                if $t_exists; then :; else

                    # Unrecognized option; note that we need to restore the
                    # leading '-' chars that getopts has sliced off.
                    #
                    printf "${PROG} (error): unrecognized long option '%s%s'; bailing out\n" "${t_pfx}" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                # We know the option was specified in one of the following forms:
                #
                #     --foo
                # or:
                #     --foo FOOVAL
                #
                # The option's long-form spec will tell us whether or not an argument is
                # expected for the option.
                #
                if test ${longopt_spec[${opt}]} -eq 1; then

                    # If bumping OPTIND would put us more than one beyond the "last pos
                    # plus one", then there is no argument provided at position OPTIND for
                    # us to consume.
                    #
                    if (( $(( $OPTIND + 1 )) > pos_last_plus_one )); then

                        printf "${PROG} (error): missing argument for option '%s%s'\n" "${t_pfx}" "${opt}" 1>&2
                        f_print_help 1>&2
                        exit 1
                    fi

                    OPTARG=${@:${OPTIND}:1}
                    (( ++OPTIND ))
                    : $PROG \(trace: $LINENO\): manually incremented OPTIND to: $OPTIND
                fi
            fi
        fi

        # Normal getopts style processing happens beneath here, with the
        # slight twist that 'opt' may contain a long-form option name.

        case $opt in

            'help' | 'h' )
                # print help message
                f_print_help
                exit 0
                ;;

            'version' | 'V' )
                # print program version info
                f_print_version
                exit 0
                ;;


            'verbose' | 'v' )
                # Accumulating 'verbose' opt. A single -v opt simply turns
                # BE_VERBOSE on (enables (additional) info-level
                # messages). Two -v opts turns on $DEBUGGING, which
                # additionally enables debug-level messages. Three or more
                # '-v' opts turns $TRACING on. Note that if you intend to turn
                # tracing on, you'll probably want your -v opts to be the
                # first opts on the command line (so they take effect
                # earlier).
                if $BE_VERBOSE; then

                    if $DEBUGGING; then

                        # We've seen at least two -v opt before, so now we're
                        # turning tracing on.

                        if $TRACING; then
                            : $PROG \(trace: $LINENO\): tracing already enabled
                        else
                            # See comments at the decl spot for $TRACING
                            # pertaining to why we maintain an "application"
                            # $TRACING flag separate from bash's built-in
                            # 'xtrace' (set -x) shell option.

                            # Enable tracking before setting our app-level
                            # $TRACING flag so that setting it is the first
                            # thing that appears in the trace.
                            set -x
                            TRACING=true
                        fi
                    else
                        # Second -v opt we're seeing
                        DEBUGGING=true
                        # Just to give a warm and fuzzy...
                        printf "${PROG} (debug): debug-level output enabled\n" 1>&2
                    fi
                else
                    # First -v opt we're seeing
                    BE_VERBOSE=true
                fi
                ;;


            ':')  # getopts put : in opt
                  printf "${PROG} (error): missing argument for option '%s%s'\n" "$t_pfx" "$OPTARG" 1>&2
                  f_print_help 1>&2
                  exit 1
                  ;;

            '?')  # getopts put ? in opt  (means "unrecognized option")
                  printf "${PROG} (error): unrecognized option '%s%s'; bailing out\n" "$t_pfx" "$OPTARG" 1>&2
                  f_print_help 1>&2
                  exit 1;
                  ;;

            * )   printf "${PROG} (BUG) [line $LINENO]: unhandled option case; opt: '$opt',  OPTARG: '$OPTARG'\n" 1>&2
                  exit 1
                  ;;
        esac
    done
fi

# shift off all arguments already handled
let ii=1;  # shell OPTIND index starts at 1
while (( ii < ${OPTIND} )); do
    shift
    (( ++ii ))
    : $PROG \(trace: $LINENO\): ii is now: $ii
done

# Unless the '--help' option or '--version' option has been specified (either
# of which would have been dealt with immediately upon parsing it above), we
# expect exactly one command line argument, which we will treat as the name to
# use to set the xterm title.

if test $# -eq 0; then
    printf "${PROG} (error): NEW_TITLE not provided; bailing out\n" 1>&2
    f_print_help 1>&2
    exit 1
fi

if test $# -gt 1; then
    printf "${PROG} (error): Only one NEW_TITLE may be provided (got %d); bailing out\n" "$#" 1>&2
    f_print_help 1>&2
    exit 1
fi

new_title=$1

if $BE_VERBOSE; then
    printf "${PROG} (info): setting title to \"%s\"\n" "${new_title}" 1>&2
fi

printf '\033]2;%s\033\' "${new_title}" \
  && exit 0

printf "${PROG} (error): was error while printing terminal title-setting code; bailing out\n" 1>&2
exit 1


# Local Variables:
#     mode: sh
#     eval: (sh-set-shell "bash" t nil)
# End:
